

- separate tree/commits into tabs

- hook git-base-shell into authx
    >>> app.test_request_context().push()
    >>> login_user(user or AnonymousUserMixin())
    now the permission checking works
    if not auth.can('read', repo):
        die('No repo with read permissions.')

- authentication

    ACLs on groups and repos, where:
        - OWNER is the owner
        - MEMBER is members of the group (or repo's group)
        - ANY is anyone

    __acl_context__ to supply a context to other rules
    build up the contxt from the __acl_bases__ 
    def __acl__(self):
        yield parent_acl_placeholder
        yield prevent_default

    The permissions are:
        write: reading, writing, merging
        write+: reading, writing, merging, forcing
        read: only reading

    Order to check permissions is:
        1. Are we an admin?
        2. Are we the owner?
        3. Check Repo ACL (if this is a repo)
        4. Check Group ACL
        5. Are we a member of the group?

    delete implies read and write
    create implies read and write
    write implies read
    there is no specific force permission

    We do this by adding some extra ACL in the front and back:
        ALLOW ADMIN ANY
        ALLOW OWNER ANY
        <repo acl>
        <group acl>
        ALLOW MEMBER write
        ALLOW ANY read (if public)




- avatars on groups and users
- group.is_user_group signals that it holds all of a user's repos

- SSH keys for users
    - update .ssh/authorized_keys
    - command="bash -c 'env | grep SSH | sort'",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty KEY

- add `update` hook to repos on creation. It is run once for every branch being
  pushed BEFORE they are accepted, allowing us to do write/force/merge control.

    - http://git-scm.com/book/en/Customizing-Git-Git-Hooks#Server-Side-Hooks
    - https://github.com/sitaramc/gitolite/blob/master/src/lib/Gitolite/Hooks/Update.pm#L110

- read-only HTTP access to the repo. This is a matter of preparing a couple of
  special index files, see:

  http://git-scm.com/book/en/Git-Internals-Transfer-Protocols#The-Dumb-Protocol


- auth via GitHub, Facebook, passwords, or one-time links which create cookies
  for access to single projects.

- example.com/pypi to give a pip-usable interface using tags.

- be able to mark repos as clones from other locations. Periodically pull them,
  OR respond when they are hit with a webhook from GitHub or a post-recieve hook.


Access control list:
    
    Permissions attached to users as a comma seperated list of strings:
        repo.create

    ACLs are a series of access control lines

        has(PERMISSION) ALLOW PERMISSION
        repo.name == self.name ALLOW write
        repo.name == self.name ALLOW force




Schema:

    User: An actual user. Does not contain repos.
        - name
        - avatar_url
        - password_hash
        - permission_blob: encoded permissions

    Group:
        - name
        - avatar_url
        - description
        - acl_blob: encoded access control list

    Repo: A repo.
        - name
        - description
        - remote_url
        - acl_blob: encoded access control list


    
Commands:

    git-base-shell: the ssh shell
    git-base-ssh-keys: generate a .ssh/authorized_keys file from the
        database
    git-base-import: add existing repos to the database

    
Name:
    git.ly
    gitly
    gitlight (too much like gitolite)
    gitter

    git pipe
    git house
    git-pump

    git-only
    gitsplore

    Git Get
    
    Git One (git-one)
    Git Me
    Git Base
    Git by Git
    Git Map

    git-stop
    git-town




