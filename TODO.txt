

- make the Users object an implementation detail. Everything is focused on
  groups. User.home points to a single group, and there is only allowed to be
  this one pointer (i.e. one-to-one relationship).

  Perhaps rename Group to be more descriptive? Perhaps:
    Collection
    RepoGroup
    RepoCollection
    Organization

  The only redundancy is that User.name/login is equal to Group.name
  Group.is_organization signals that this is not a person. It can still have
  an owner/creator, but that isn't really displayed.

- what permission is there for creating groups?
- what permission is there for creating repos in groups?

- separate tree/commits into tabs
- auth view for repos, showing what everyone can do it with

- hook git-base-shell into authx

    - check for basic write permissions on git-receive-pack and git
    >>> app.test_request_context().push()
    >>> login_user(user or AnonymousUserMixin())
    now the permission checking works
    if not auth.can('read', repo):
        die('No repo with read permissions.')




- avatars on groups and users
- group.is_user_group signals that it holds all of a user's repos and should
  proxy a bunch of the details

- SSH keys for users
    - update .ssh/authorized_keys
    - command="bash -c 'env | grep SSH | sort'",no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty KEY

- add `update` hook to repos on creation. It is run once for every branch being
  pushed BEFORE they are accepted, allowing us to do write/force/merge control.

    - http://git-scm.com/book/en/Customizing-Git-Git-Hooks#Server-Side-Hooks
    - https://github.com/sitaramc/gitolite/blob/master/src/lib/Gitolite/Hooks/Update.pm#L110

- read-only HTTP access to the repo. This is a matter of preparing a couple of
  special index files, see:

  http://git-scm.com/book/en/Git-Internals-Transfer-Protocols#The-Dumb-Protocol


- auth via GitHub, Facebook, passwords, or one-time links which create cookies
  for access to single projects.

- example.com/pypi to give a pip-usable interface using tags.

- be able to mark repos as clones from other locations. Periodically pull them,
  OR respond when they are hit with a webhook from GitHub or a post-recieve hook.


Access control list:
    
    Permissions attached to users as a comma seperated list of strings:
        repo.create

    ACLs are a series of access control lines

        has(PERMISSION) ALLOW PERMISSION
        repo.name == self.name ALLOW write
        repo.name == self.name ALLOW force




Schema:

    User: An actual user. Does not contain repos.
        - name
        - avatar_url
        - password_hash
        - permission_blob: encoded permissions

    Group:
        - name
        - avatar_url
        - description
        - acl_blob: encoded access control list

    Repo: A repo.
        - name
        - description
        - remote_url
        - acl_blob: encoded access control list


    
Commands:

    git-base-shell: the ssh shell
    git-base-ssh-keys: generate a .ssh/authorized_keys file from the
        database
    git-base-import: add existing repos to the database

    
Name:
    git.ly
    gitly
    gitlight (too much like gitolite)
    gitter

    git pipe
    git house
    git-pump

    git-only
    gitsplore

    Git Get
    
    Git One (git-one)
    Git Me
    Git Base
    Git by Git
    Git Map

    git-stop
    git-town




