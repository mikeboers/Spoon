
INITIAL
=======

- refactor into a RootsExtension (and RootsBlueprint)
  - all of the exts that it creates be attributes on the extension
  - self.extend_with(name, class_)
  

- gem/node commands
- take over manage
  - perhaps create a new one called `roots`, and leave the manage scripts the
    way that they are?


IMPROVEMENTS
============

- `bin/roots-bootstrap` creates the `bin/activate` script, which sets up the
  Python virtualenv, and Ruby/Node/Bower paths. It is questionable whether the
  non-Python paths should be baked into the bin/activate, or if they should be
  setup by the installed Flask-Roots.

- `bin/roots-bootstrap /tmp/myapp` stuffs runtime stuff there instead
  of in "$FLASK_ROOT_PATH/var". It stores this in `$FLASK_INSTANCE_PATH` via the `bin/.rootsenv`
  script.

- activate/bootstrap pulls package name from:

    export APP_NAME=$(python setup.py --name 2>/dev/null)

- pull wsgi_app via entrypoint; see http://stackoverflow.com/a/9615473/66502

- It will provide an easy mechanism for Python/Ruby/Node/general packages, but
  won't actually administer them itself.

  roots {pip,gem,npm,bower} {install,freeze}
  roots packages freeze -> freeze them all
  roots packages install -> install from etc/{pip,gem,npm,bower}-requirements.txt

- configuration decorators:

    @provides('logging')
    @requires('ADMINS')
    def setup_logging(config):
        config.setdefault('LOG_DEFAULT_LEVEL', logging.INFO)
        for admin in config.get('ADMINS', []):
            # Setup email logger.
            pass

    -- OR --

    @defer(requires='ADMINS', provides='logging')
    def setup_logging(config):
        pass

    @defer(priority=500)
    def _something(config):
        pass

- subcommands via argparse. flask_roots.commands package will be walked looking
  for `register_command` functions.

- base commands for fabric in flask_roots.fabric.exports:
    in manage.py: from flask.ext.roots.fabric.exports import *

- for path in flask_roots.utils.iter_resources('etc/*-requirements.txt', instance_first=True):
    iterate across the various paths: roots/etc, app/etc, app/var/etc

    Find these via FLASK_INSTANCE_PATH, FLASK_ROOT_PATH, and relative to flask_roots
    (via the root_path on the Flask-Roots Blueprint).

    This is very similar to `Flask.open_instance_resource(path)`.




