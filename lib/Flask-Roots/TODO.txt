
INITIAL
=======

- how to identify Flask app to roots

  x entrypoint; rejected as I don't want to name entrypoints
  - setup.cfg or roots.cfg
      [flask]
      app = spoon.web:app
  - rootfile.py (like fabfile.py): it can just __import__('rootconfig')
    and pull what it needs off of it
  - environment variable; FLASK_ENTRYPOINT
  - APP_ENTRYPOINT in the etc/flask files: this would require loading the
    config to find the app which already loaded the config...

- how to setup this identification:

  - roots-config --app spoon.web:app --id com.mikeboers.git.www
      this would set ENTRYPOINT and FLASK_INSTANCE_ID

- perhaps this should be done the other way around, in which my apps are blueprints
  that get registered onto Roots' app? This wouldn't work very great for testing...


- get Roots into template path
- get Roots into static path, maybe; this may not be nessesary since others can
  register blueprints which provide their own static folders

- gem/node commands
- take over manage
  - perhaps create a new one called `roots`, and leave the manage scripts the
    way that they are?


IMPROVEMENTS
============

- be able to set FLASK_INSTANCE_PATH


- activate/bootstrap pulls package name from:

    export APP_NAME=$(python setup.py --name 2>/dev/null)

- pull wsgi_app via entrypoint; see http://stackoverflow.com/a/9615473/66502

- It will provide an easy mechanism for Python/Ruby/Node/general packages, but
  won't actually administer them itself.

  roots {pip,gem,npm,bower} {install,freeze}
  roots packages freeze -> freeze them all
  roots packages install -> install from etc/{pip,gem,npm,bower}-requirements.txt

- configuration decorators:

    @provides('logging')
    @requires('ADMINS')
    def setup_logging(config):
        config.setdefault('LOG_DEFAULT_LEVEL', logging.INFO)
        for admin in config.get('ADMINS', []):
            # Setup email logger.
            pass

    -- OR --

    @defer(requires='ADMINS', provides='logging')
    def setup_logging(config):
        pass

    @defer(priority=500)
    def _something(config):
        pass

- subcommands via argparse. flask_roots.commands package will be walked looking
  for `register_command` functions.

- base commands for fabric in flask_roots.fabric.exports:
    in manage.py: from flask.ext.roots.fabric.exports import *

- for path in flask_roots.utils.iter_resources('etc/*-requirements.txt', instance_first=True):
    iterate across the various paths: roots/etc, app/etc, app/var/etc

    Find these via FLASK_INSTANCE_PATH, FLASK_ROOT_PATH, and relative to flask_roots
    (via the root_path on the Flask-Roots Blueprint).

    This is very similar to `Flask.open_instance_resource(path)`.




